# Отчёт по лабораторной работе №5

## Тема: Современные средства взаимодействия с API — `fetch`, `Promise`, архитектурные принципы и клиентское хранение данных

---

## 1. Call Stack и Event Loop

### Определение и взаимосвязь

**Call Stack** — это стек вызовов функций, используемый JavaScript-движком для отслеживания текущего контекста выполнения. Поскольку JavaScript является однопоточным языком, в каждый момент времени может выполняться только одна функция — та, что находится на вершине стека.

**Event Loop** — это циклический механизм, координирующий выполнение кода, обработку событий и асинхронных операций. Он постоянно проверяет, пуст ли Call Stack, и при его опустошении перемещает задачи из очередей (callback queue, microtask queue) в стек для выполнения.

Эти два компонента **неразрывно связаны**: Call Stack управляет синхронным выполнением, а Event Loop обеспечивает асинхронное поведение, позволяя JavaScript быть неблокирующим.

### Типы задач и порядок обработки

Существует два типа асинхронных задач:

- **Macrotasks** (очередь задач): `setTimeout`, `setInterval`, I/O-события, сетевые запросы.
- **Microtasks** (очередь микрозадач): `Promise.then/catch`, `queueMicrotask`.

**Приоритет обработки**:

1. Выполняется весь синхронный код.
2. Event Loop полностью опустошает **очередь микрозадач**.
3. Выполняется **одна макрозадача**.
4. Снова опустошается очередь микрозадач — и так далее.

### Пример

```js
console.log('A');
setTimeout(() => console.log('B'), 0);
Promise.resolve().then(() => console.log('C'));
console.log('D');
```

**Вывод**:

```
A
D
C
B
```

Обоснование: синхронный код → микрозадача → макрозадача.

---

## 2. Promise

### Определение и назначение

`Promise` — это специальный объект JavaScript, представляющий результат асинхронной операции, которая может завершиться успешно (`fulfilled`) или с ошибкой (`rejected`). Он был введён для устранения «ада коллбэков» и стандартизации асинхронного кода.

### Где используется

- `fetch()` — возвращает `Promise<Response>`
- `async/await` — синтаксический сахар над `Promise`
- Работа с файлами, IndexedDB, геолокацией и другими асинхронными API

### Состояния и методы обработки

Promise имеет три состояния:

- **pending** — начальное состояние
- **fulfilled** — операция завершена успешно
- **rejected** — операция завершена с ошибкой

Обработка:

```js
promise
  .then(result => { /* успех */ })
  .catch(error => { /* ошибка */ })
  .finally(() => { /* всегда */ });
```

### Статические методы

| Метод               | Назначение                                                                                                               |
| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------- |
| `Promise.all()`        | Ждёт все промисы; при первой ошибке — отклоняет                                             |
| `Promise.allSettled()` | Ждёт все промисы; возвращает статус каждого                                                   |
| `Promise.race()`       | Возвращает результат первого завершённого промиса                                     |
| `Promise.any()`        | Возвращает первый**успешный** промис; при полном провале — `AggregateError` |

---

## 3. Fetch API

### Назначение

`fetch()` — это современный встроенный метод для выполнения HTTP-запросов. Он заменяет устаревший `XMLHttpRequest`, предоставляя более чистый, промис-ориентированный интерфейс.

### Основные параметры (`options`)

```js
fetch(url, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(data),
  mode: 'cors',
  credentials: 'include',   // для отправки cookies
  cache: 'no-store'
})
```

### Особенности

- Не выбрасывает исключение при HTTP-ошибках (404, 500) — необходимо проверять `response.ok`.
- Для POST-запросов в VK API требуется указывать `Content-Type: application/x-www-form-urlencoded` и передавать тело через `URLSearchParams`.

---

## 4. Принципы проектирования: DRY, KISS, SOLID

### DRY (Don’t Repeat Yourself)

> Каждая логическая сущность должна иметь единственное представление в системе.

**Пример**:
Вынесение формирования URL-адресов VK API в отдельную функцию `buildVkUrl()` в `modules/urls.js`, вместо дублирования логики в каждом компоненте.

### KISS (Keep It Simple, Stupid)

> Простота предпочтительнее сложности.

**Пример**:
Использование простой функции-хелпера вместо создания класса `Ajax` для `fetch`.

### SOLID

- **S (Single Responsibility)**: Каждый компонент (`MainPage`, `UserPage`) отвечает за одну зону ответственности.
- **O (Open/Closed)**: Структура приложения позволяет добавлять новые страницы без изменения ядра (`App.js`).
- **L (Liskov Substitution)**: Все страницы реализуют единый интерфейс (`render()`).
- **I (Interface Segregation)**: Компоненты содержат только необходимые методы.
- **D (Dependency Inversion)**: Модули зависят от конфигурации (`consts.js`), а не от жёстко закодированных значений.

---

## 5. Web Storage API

Web Storage предоставляет два механизма клиентского хранения данных:

### `localStorage`

- **Время жизни**: постоянное (до ручной очистки).
- **Область видимости**: все вкладки одного origin.
- **Методы**:
  ```js
  localStorage.setItem('key', 'value');
  localStorage.getItem('key');
  localStorage.removeItem('key');
  localStorage.clear();
  ```

### `sessionStorage`

- **Время жизни**: до закрытия вкладки.
- **Область видимости**: только текущая вкладка.
- **Методы**: идентичны `localStorage`.

### Сравнение

| Критерий                            | `localStorage`                           | `sessionStorage`                         |
| ------------------------------------------- | ------------------------------------------ | ------------------------------------------ |
| Жизненный цикл                 | Постоянный                       | До закрытия вкладки       |
| Доступ между вкладками  | Да                                       | Нет                                     |
| Типичное использование | Настройки, темы, токены | Временные данные формы |

> ⚠️ Оба хранилища работают **только со строками**. Для объектов требуется сериализация через `JSON.stringify()` / `JSON.parse()`.
